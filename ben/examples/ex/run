#!/usr/bin/env python

"""
Simple run_script example that runs a program call "prog.[Linux|Darwin].exe" , which 
takes as input a list of varname and value and 
returns to stdout (the terminal screen) the name of the file consisting of covered lines

e.g.,
./test_script "x 0, y 1, z 0 ..."   #this represent the configuration x = 0 , y = 1 z = 0 ...
/var/tmp/tvn.hash_of_config_.out

"""
import argparse
import os.path
import subprocess as sp
import platform
import sys

def vcmd(cmd, inp=None, shell=True):
    proc = sp.Popen(cmd, shell=shell, stdin=sp.PIPE,
                    stdout=sp.PIPE, stderr=sp.PIPE)
    return proc.communicate(input=inp)


if __name__ == "__main__":
    # note:  use abspath (considers symlinks) instead of realpath (ignore symlinks)
    me_file = os.path.abspath(os.path.expanduser(__file__))
    me_dir = os.path.dirname(me_file)

    parser = argparse.ArgumentParser()
    parser.add_argument("inputs", help="input configurations")
    args = parser.parse_args()
    inputs = args.inputs.strip()  # "x 0, y 1, z 0"
    parts = [p.split() for p in inputs.split(",")]
    varnames, varvals = zip(*parts)
    assert len(varnames) == len(varvals)

    prog_exe = os.path.join(me_dir, "prog.{}.exe".format(platform.system()))
    prog_inp = ' '.join(varvals)  # "0 1 0"
    hashv = hash(prog_inp)
    prog_out = "/var/tmp/tvn.{}.out".format(hashv)

    #assert not os.path.isfile(prog_out), "{} exists".format(prog_out)

    cmd = "{} {} > {}".format(prog_exe, prog_inp, prog_out)
    try:
        _, rs_err = vcmd
        assert not rs_err, rs_err
    except:
        e = sys.exc_info()[0]
        print("cmd '{}' failed: {}".format(cmd, e))

    print(prog_out)
