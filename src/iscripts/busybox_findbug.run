#!/usr/bin/env python2.7

"""
"""
import argparse
import os.path
import subprocess as sp

def vcmd(cmd, inp=None, shell=True):
    proc = sp.Popen(cmd,shell=shell,stdin=sp.PIPE,stdout=sp.PIPE,stderr=sp.PIPE)
    rs =  proc.communicate(input=inp)
    exit_code = proc.wait()
    return rs, exit_code

def runcmd(cmd):
    try:
        print '$', cmd
        (_,rs_err), exit_code = vcmd(cmd)
        #assert not rs_err, rs_err
        #print 'ecode', exit_code
        return exit_code
    except:
        print("cmd '{}' failed".format(cmd))
        return -1

def phash(v):
    import sys
    return hash(v) % ((sys.maxsize + 1) * 2)
    

def similar(tdir, f1, f2):
    tf1 = "{}/f1.txt".format(tdir)
    tf2 = "{}/f2.txt".format(tdir)

    assert runcmd("rm -rf {} {}".format(tf1, tf2)) == 0

    cleansort = lambda f, tf: "cat {} | sort | egrep \"^(CONFIG_|# CONFIG_.*is not set)\" > {}".format(f, tf)
    assert runcmd(cleansort(f1, tf1))  == 0
    assert runcmd(cleansort(f2, tf2))  == 0
    return runcmd("diff {} {}".format(tf1, tf2)) == 0
    
                 
if __name__ == "__main__":
    #note:  use abspath (considers symlinks) instead of realpath (ignore symlinks)
    me_file = os.path.abspath(os.path.expanduser(__file__))  
    me_dir = os.path.dirname(me_file)

    parser = argparse.ArgumentParser()
    parser.add_argument("inputs", help="input configurations")
    args = parser.parse_args()
    inp = args.inputs.strip() #"x 0, y 1, z 0"

    import time
    tid = "{}.{}".format(time.time(), phash(inp))


    BENCH_DIR="/home/tnguyen/Dropbox/git/vb_bench/busybox"
    TMP_DIR = "/var/tmp"
    ORIG_SRC_DIR= "{}/busybox-working".format(BENCH_DIR)
    defConfigFile="{}/defconfig.tmp".format(BENCH_DIR)    


    name="igen_busybox"
    SRC_DIR = "{}/{}-{}".format(TMP_DIR, name, tid)
    configFile="{}/.config".format(SRC_DIR)
    configFileBackup="{}/config.backup".format(SRC_DIR)

    assert not os.path.isdir(SRC_DIR), SRC_DIR

    assert runcmd("cp -r {} {}".format(ORIG_SRC_DIR, SRC_DIR)) == 0
    assert runcmd("cd {} && make distclean > clean.log 2>&1".format(SRC_DIR)) == 0
    assert runcmd("cp {} {}".format(defConfigFile, configFile)) == 0

    parts =  [p.split() for p in inp.split(",")]
    ys, ns = [], []
    for name, val in parts:
        assert val == 'y' or val == 'n', val
        
        ls = ys if val == 'y' else ns
        ls.append(name)

    setcmd = lambda name: \
             "sed -e 's/.*{} .*/{}=y/' -i {}".format(name, name, configFile)

    unsetcmd = lambda name:\
               "sed -e 's/.*{}=y.*/# {} is not set/' -i {}".format(
                   name, name, configFile)
    
    for name in ys:
        runcmd(setcmd(name))
        
    for name in ns:
        runcmd(unsetcmd(name))
        
    assert runcmd("cp {} {}".format(configFile, configFileBackup)) == 0


    #runtest
    logFile = "{}/build.log".format(SRC_DIR)


    assert runcmd("echo \"---Configuration:{}, stime+hash:{}\n\" > {} 2>&1".format(
        inp, tid, logFile)) == 0

    mkOldConfigCmd = lambda : runcmd("cd {} && make oldconfig >> {} 2>&1".format(
        SRC_DIR, logFile))

    # compareCmd = lambda: runcmd("./compare_configs.sh {} {} >> {} 2>&1".format(
    #     configFile, configFileBackup, logFile))

    mkCmd = lambda : runcmd("cd {} && make >> {} 2>&1".format(SRC_DIR, logFile))

    statCmd = lambda : runcmd("{}/busybox stat {} >> {} 2>&1".format(SRC_DIR, defConfigFile, logFile)) 

    found = True
    if mkOldConfigCmd() != 0:
        found = False

    if found and not similar(SRC_DIR, configFile, configFileBackup):
        found = False
    
    if found and mkCmd() != 0:
        found = False

    if found and statCmd() != 139:
        found = False

    resultFile = "{}/{}_{}_interesting.txt".format(TMP_DIR, name, tid)        
    if found:
        runcmd("echo stat.139 >> {}".format(resultFile))
    else:
        runcmd("touch {}".format(resultFile))

    print resultFile
    
